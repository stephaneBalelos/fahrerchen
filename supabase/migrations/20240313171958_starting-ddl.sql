
-- Custom types
create type public.app_permission as enum ('organisations.delete', 'courses.delete');
create type public.app_role as enum ('super_admin', 'owner', 'admin','manager', 'teacher', 'student' );
create type public.user_status as enum ('ONLINE', 'OFFLINE');

-- USERS
create table public.users (
  id          uuid references auth.users not null primary key, -- UUID from auth.users
  email       text not null unique,
  firstname    text,
  lastname    text,
  birth_date   date,
  status      user_status default 'OFFLINE'::public.user_status
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

-- ORGANISATION
create table public.organisations (
  id            uuid default uuid_generate_v4() primary key,
  inserted_at   timestamp with time zone default timezone('utc'::text, now()) not null,
  name          text not null,
  owner_id      uuid references auth.users not null
);
comment on table public.organisations is 'Organisation data.';

-- COURSES
create table public.courses (
  id            uuid default uuid_generate_v4() primary key,
  inserted_at   timestamp with time zone default timezone('utc'::text, now()) not null,
  description       text,
  organisation_id    uuid references public.organisations not null
);
comment on table public.courses is 'COURSES AVAILABLE.';


create type public.lesson_type as enum ('THEORY', 'PRACTICE', 'EXAM', 'OTHER');

-- COURSES LESSONS
create table public.lessons (
  id            uuid default uuid_generate_v4() primary key,
  inserted_at   timestamp with time zone default timezone('utc'::text, now()) not null,
  type          lesson_type not null,
  mandatory     boolean not null,
  description   text,
  price       numeric(10, 2) not null,
  course_id    uuid references public.courses not null
);
comment on table public.courses is 'LESSONS AVAILABLE IN A COURSE.';

-- COURSES SUBSCRIPTIONS
create table public.courses_subscription (
  id            uuid default uuid_generate_v4() primary key,
  inserted_at   timestamp with time zone default timezone('utc'::text, now()) not null,
  description       text,
  course_id    uuid references public.courses not null,
  user_id    uuid references public.users on delete cascade not null 
);
comment on table public.courses is 'COURSES AVAILABLE.';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- -- authorize with role-based access control (RBAC)
-- create function public.authorize(
--   requested_permission app_permission
-- )
-- returns boolean as $$
-- declare
--   bind_permissions int;
-- begin
--   select count(*)
--   from public.role_permissions
--   where role_permissions.permission = authorize.requested_permission
--     and role_permissions.role = (auth.jwt() ->> 'user_role')::public.app_role
--   into bind_permissions;
  
--   return bind_permissions > 0;
-- end;
-- $$ language plpgsql security definer set search_path = public;

-- -- Secure the tables
-- alter table public.users enable row level security;
-- alter table public.organisations enable row level security;
-- alter table public.courses enable row level security;
-- alter table public.user_roles enable row level security;
-- alter table public.role_permissions enable row level security;
-- create policy "Allow logged-in read access" on public.users for select using ( auth.role() = 'authenticated' );
-- create policy "Allow individual insert access" on public.users for insert with check ( auth.uid() = id );
-- create policy "Allow individual update access" on public.users for update using ( auth.uid() = id );
-- create policy "Allow logged-in read access" on public.organisations for select using ( auth.role() = 'authenticated' );
-- create policy "Allow individual insert access" on public.organisations for insert with check ( auth.uid() = created_by );
-- create policy "Allow individual delete access" on public.organisations for delete using ( auth.uid() = created_by );
-- create policy "Allow authorized delete access" on public.organisations for delete using ( authorize('organisations.delete') );
-- create policy "Allow logged-in read access" on public.courses for select using ( auth.role() = 'authenticated' );
-- create policy "Allow individual insert access" on public.courses for insert with check ( auth.uid() = user_id );
-- create policy "Allow individual update access" on public.courses for update using ( auth.uid() = user_id );
-- create policy "Allow individual delete access" on public.courses for delete using ( auth.uid() = user_id );
-- create policy "Allow authorized delete access" on public.courses for delete using ( authorize('courses.delete') );
-- create policy "Allow individual read access" on public.user_roles for select using ( auth.uid() = user_id );

-- -- Send "previous data" on change 
-- alter table public.users replica identity full; 
-- alter table public.organisations replica identity full; 
-- alter table public.courses replica identity full;

-- -- inserts a row into public.users and assigns roles
create function public.handle_new_user() 
returns trigger as $$
declare is_admin boolean;
begin
  insert into public.users (id, email)
  values (new.id, new.email);
  
  return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- /**
--  * REALTIME SUBSCRIPTIONS
--  * Only allow realtime listening on public tables.
--  */

-- begin; 
--   -- remove the realtime publication
--   drop publication if exists supabase_realtime; 

--   -- re-create the publication but don't enable it for any tables
--   create publication supabase_realtime;  
-- commit;

-- -- add tables to the publication
-- alter publication supabase_realtime add table public.organisations;
-- alter publication supabase_realtime add table public.courses;
-- alter publication supabase_realtime add table public.users;

-- /**
--  * HELPER FUNCTIONS
--  * Create test user helper method.
--  */
-- create or replace function public.create_user(
--     email text
-- ) returns uuid
--     security definer
--     set search_path = auth
-- as $$
--   declare
--   user_id uuid;
-- begin
--   user_id := extensions.uuid_generate_v4();
  
--   insert into auth.users (id, email)
--     values (user_id, email)
--     returning id into user_id;

--     return user_id;
-- end;
-- $$ language plpgsql;